import * as React from 'react';
import { useThemeClassName_unstable as useThemeClassName, useFluent_unstable as useFluent, usePortalMountNode as usePortalMountNodeContext } from '@fluentui/react-shared-contexts';
import { mergeClasses } from '@griffel/react';
import { useFocusVisible } from '@fluentui/react-tabster';
import { usePortalMountNodeStylesStyles } from './usePortalMountNodeStyles.styles';
const useInsertionEffect = React['useInsertion' + 'Effect'];
/**
 * Legacy element factory for React 17 and below. It's not safe for concurrent rendering.
 *
 * Creates a new element on a "document.body" to mount portals.
 */ const useLegacyElementFactory = (options)=>{
    const { className, dir, focusVisibleRef, targetNode } = options;
    const targetElement = React.useMemo(()=>{
        if (targetNode === undefined || options.disabled) {
            return null;
        }
        const element = targetNode.ownerDocument.createElement('div');
        targetNode.appendChild(element);
        return element;
    }, [
        targetNode,
        options.disabled
    ]);
    // Heads up!
    // This useMemo() call is intentional for React 17 & below.
    //
    // We don't want to re-create the portal element when its attributes change. This also cannot not be done in an effect
    // because, changing the value of CSS variables after an initial mount will trigger interesting CSS side effects like
    // transitions.
    React.useMemo(()=>{
        if (!targetElement) {
            return;
        }
        targetElement.className = className;
        targetElement.setAttribute('dir', dir);
        targetElement.setAttribute('data-portal-node', 'true');
        // eslint-disable-next-line react-compiler/react-compiler
        focusVisibleRef.current = targetElement;
    }, [
        className,
        dir,
        targetElement,
        focusVisibleRef
    ]);
    React.useEffect(()=>{
        return ()=>{
            targetElement === null || targetElement === void 0 ? void 0 : targetElement.remove();
        };
    }, [
        targetElement
    ]);
    return targetElement;
};
/**
 * This is a modern element factory for React 18 and above. It is safe for concurrent rendering.
 *
 * It abuses the fact that React will mount DOM once (unlike hooks), so by using a proxy we can intercept:
 * - the `remove()` method (we call it in `useEffect()`) and remove the element only when the portal is unmounted
 * - all other methods (and properties) will be called by React once a portal is mounted
 */ const useModernElementFactory = (options)=>{
    const { className, dir, focusVisibleRef, targetNode } = options;
    const [elementFactory] = React.useState(()=>{
        let currentElement = undefined;
        function get(targetRoot, forceCreation) {
            if (currentElement) {
                return currentElement;
            }
            if (forceCreation) {
                currentElement = targetRoot.ownerDocument.createElement('div');
                targetRoot.appendChild(currentElement);
            }
            return currentElement;
        }
        function dispose() {
            if (currentElement) {
                currentElement.remove();
                currentElement = undefined;
            }
        }
        return {
            get,
            dispose
        };
    });
    const elementProxy = React.useMemo(()=>{
        if (targetNode === undefined || options.disabled) {
            return null;
        }
        return new Proxy({}, {
            get (_, property) {
                // Heads up!
                // We intercept the `remove()` method to remove the mount node only when portal has been unmounted already.
                if (property === 'remove') {
                    const targetElement = elementFactory.get(targetNode, false);
                    if (targetElement) {
                        // If the mountElement has children, the portal is still mounted
                        const portalHasNoChildren = targetElement.childNodes.length === 0;
                        if (portalHasNoChildren) {
                            return targetElement.remove.bind(targetElement);
                        }
                    }
                    return ()=>{
                    // If the mountElement has children, ignore the remove call
                    };
                }
                const targetElement = elementFactory.get(targetNode, true);
                const targetProperty = targetElement[property];
                if (typeof targetProperty === 'function') {
                    return targetProperty.bind(targetElement);
                }
                return targetProperty;
            },
            set (_, property, value) {
                const targetElement = elementFactory.get(targetNode, true);
                if (targetElement) {
                    Object.assign(targetElement, {
                        [property]: value
                    });
                    return true;
                }
                return false;
            }
        });
    }, [
        elementFactory,
        targetNode,
        options.disabled
    ]);
    React.useEffect(()=>{
        return ()=>{
            elementProxy === null || elementProxy === void 0 ? void 0 : elementProxy.remove();
        };
    }, [
        elementProxy
    ]);
    useInsertionEffect(()=>{
        if (!elementProxy) {
            return;
        }
        const classesToApply = className.split(' ').filter(Boolean);
        elementProxy.classList.add(...classesToApply);
        elementProxy.setAttribute('dir', dir);
        elementProxy.setAttribute('data-portal-node', 'true');
        focusVisibleRef.current = elementProxy;
        return ()=>{
            elementProxy.classList.remove(...classesToApply);
            elementProxy.removeAttribute('dir');
        };
    }, [
        className,
        dir,
        elementProxy,
        focusVisibleRef
    ]);
    return elementProxy;
};
/**
 * Creates a new element on a "document.body" to mount portals.
 */ export const usePortalMountNode = (options)=>{
    'use no memo';
    const { targetDocument, dir } = useFluent();
    const mountNode = usePortalMountNodeContext();
    const focusVisibleRef = useFocusVisible();
    const classes = usePortalMountNodeStylesStyles();
    const themeClassName = useThemeClassName();
    const factoryOptions = {
        dir,
        disabled: options.disabled,
        focusVisibleRef,
        className: mergeClasses(themeClassName, classes.root, options.className),
        targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
    };
    if (useInsertionEffect) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useModernElementFactory(factoryOptions);
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return useLegacyElementFactory(factoryOptions);
};
